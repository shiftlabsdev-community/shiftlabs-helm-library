replicaCount: 1

ExternalSecret:
  enabled: false
  type: hashicorp
  # Supported types: hashicorp, aws, gcp, azure
  kvPath:
    - shiftlabsdev/dev/
  name: vault-backend
  # AWS Secrets Manager specific
  region: us-east-1
  # GCP Secret Manager specific
  projectId: ""
  # Azure Key Vault specific
  vaultUrl: ""

image:
  repository: nginx
  pullPolicy: Always
  tag: ""

imagePullSecrets:
  - name: registry-secret

nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # runAsNonRoot: true
  # seccompProfile:
  #   type: RuntimeDefault

env: []
  # - name: ENV_VAR_NAME
  #   value: "value"
  # - name: SECRET_ENV
  #   valueFrom:
  #     secretKeyRef:
  #       name: my-secret
  #       key: secret-key

securityContext: {}
  # allowPrivilegeEscalation: false
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # capabilities:
  #   drop:
  #     - ALL

service:
  type: ClusterIP
  loadBalancerIP: ""
  ports:
    - port: 80
      targetPort: 80
      name: http
      protocol: TCP
    - port: 8080
      targetPort: 8080
      name: custom-port-1
      protocol: TCP

initContainers:
  enabled: false
  containers: []
    # - name: "init-container"
    #   image: "busybox"
    #   command: ["sh"]
    #   args: ['-c', 'echo "INIT1"']
    # - name: "init-container2"
    #   image: "busybox"
    #   command: ["sh"]
    #   args: ['-c', 'echo "INIT2"']

ingress:
  enabled: false

  # className: The Kubernetes IngressClass name. Can be ANY custom name.
  # Examples: "haproxy", "haproxy-internal", "nginx-public", "my-custom-ingress"
  className: haproxy

  # controllerType: Determines which ANNOTATION FORMAT to generate.
  # This is INDEPENDENT of className — className can be anything.
  #   "haproxy" → generates haproxy.org/* annotations
  #   "nginx"   → generates nginx.ingress.kubernetes.io/* annotations
  # Default: "nginx" (if not specified)
  controllerType: haproxy

  # ┌──────────────────────────────────────────────────────────────────┐
  # │ FEATURE SUPPORT MATRIX                                          │
  # │                                                                  │
  # │ Feature              │ HAProxy (annotation) │ NGINX (annotation) │
  # │ ─────────────────────┼──────────────────────┼─────────────────── │
  # │ securityHeaders      │ ✅ response-set-header│ ✅ config-snippet  │
  # │ ssl.redirect         │ ✅                    │ ✅                  │
  # │ ssl.protocols        │ ❌ (ConfigMap)        │ ✅                  │
  # │ ssl.ciphers          │ ❌ (ConfigMap)        │ ✅                  │
  # │ proxy.connectTimeout │ ✅ timeout-connect    │ ✅                  │
  # │ proxy.sendTimeout    │ ✅ (timeout-server)   │ ✅                  │
  # │ proxy.readTimeout    │ ✅ (timeout-server)   │ ✅                  │
  # │ proxy.bodySize       │ ❌ (ConfigMap)        │ ✅                  │
  # │ proxy.bufferSize     │ ❌ (ConfigMap)        │ ✅                  │
  # │ proxy.nextUpstream   │ ❌ (ConfigMap)        │ ✅                  │
  # │ rateLimit            │ ✅ rate-limit-requests│ ✅ limit-rps        │
  # │ rateLimit.burst      │ ❌                    │ ✅ burst-multiplier │
  # │ rateLimit.key        │ ❌                    │ ❌ (NGINX default)  │
  # │ cors                 │ ✅ response-set-header│ ✅ enable-cors      │
  # │ websocket            │ ✅ timeout-tunnel     │ ✅ websocket-svc    │
  # │ canary               │ ❌ (not supported)    │ ✅ canary-weight    │
  # │                                                                  │
  # │ ❌ (ConfigMap) = Configure via HAProxy Ingress Controller        │
  # │                  ConfigMap instead of per-Ingress annotations    │
  # └──────────────────────────────────────────────────────────────────┘

  # Security Headers [HAProxy: ✅ | NGINX: ✅]
  securityHeaders:
    enabled: false
    hsts: true                              # [HAProxy: ✅ | NGINX: ✅]
    hstsMaxAge: 31536000                    # 1 year
    hstsIncludeSubdomains: true
    hstsPreload: false
    frameOptions: "SAMEORIGIN"              # DENY, SAMEORIGIN, or ALLOW-FROM
    contentTypeNosniff: true
    xssProtection: "1; mode=block"
    referrerPolicy: "strict-origin-when-cross-origin"
    csp: ""
      # Example: "default-src 'self'; script-src 'self' 'unsafe-inline';"

  # SSL/TLS Configuration
  ssl:
    redirect: true                          # [HAProxy: ✅ | NGINX: ✅]
    protocols: "TLSv1.2 TLSv1.3"           # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    ciphers: ""                             # [HAProxy: ❌ ConfigMap | NGINX: ✅]

  # Performance & Reliability
  proxy:
    bodySize: "8m"                          # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    connectTimeout: 60                      # [HAProxy: ✅ timeout-connect | NGINX: ✅]
    sendTimeout: 60                         # [HAProxy: ✅ timeout-server (max of send/read) | NGINX: ✅]
    readTimeout: 60                         # [HAProxy: ✅ timeout-server (max of send/read) | NGINX: ✅]
    bufferSize: "4k"                        # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    buffersNumber: 4                        # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    nextUpstream: "error timeout"           # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    nextUpstreamTries: 3                    # [HAProxy: ❌ ConfigMap | NGINX: ✅]

  # Rate Limiting [HAProxy: ✅ | NGINX: ✅]
  rateLimit:
    enabled: false
    rps: 100                                # [HAProxy: ✅ rate-limit-requests | NGINX: ✅ limit-rps]
    burst: 200                              # [HAProxy: ❌ | NGINX: ✅ burst-multiplier]
    key: "$binary_remote_addr"              # [HAProxy: ❌ | NGINX: ❌]

  # CORS [HAProxy: ✅ response-set-header | NGINX: ✅ enable-cors]
  cors:
    enabled: false
    allowOrigin: "*"
    allowMethods: "GET, POST, PUT, DELETE, PATCH, OPTIONS"
    allowHeaders: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization"
    allowCredentials: true
    maxAge: 3600

  # Websocket Support [HAProxy: ✅ timeout-tunnel | NGINX: ✅ websocket-services]
  websocket:
    enabled: false

  # Canary Deployment [HAProxy: ❌ not supported | NGINX: ✅ canary-weight]
  canary:
    enabled: false
    weight: 0

  # Custom annotations (merged with auto-generated ones)
  extraAnnotations: {}
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
    # external-dns.alpha.kubernetes.io/hostname: "app.example.com"

  # Extra labels
  extraLabels: {}

  hosts:
    - host: fqdn.shiftlabs.dev
      paths:
        - path: /
          pathType: Prefix

  tls:
    - secretName: shiftlabsdev-ssl-cert
      hosts:
        - fqdn.shiftlabs.dev

ingressGRPC:
  enabled: false
  className: haproxy           # Kubernetes IngressClass name (any custom name)
  controllerType: haproxy      # "haproxy" or "nginx" — annotation format (independent of className)

  # gRPC-specific settings
  # [HAProxy: ✅ server-proto h2 + timeout-tunnel | NGINX: ✅ backend-protocol GRPC + config-snippet]
  grpc:
    timeout: 300               # [HAProxy: ✅ timeout-tunnel | NGINX: ✅ grpc_read/send_timeout]
    maxMessageSize: "4m"       # [HAProxy: ❌ | NGINX: ✅ client_max_body_size]
    keepaliveTime: 30          # [HAProxy: ❌ | NGINX: ❌] — configure at controller level
    keepaliveTimeout: 10       # [HAProxy: ❌ | NGINX: ❌]
    keepalivePermitWithoutCalls: false

  # Security Headers [HAProxy: ✅ | NGINX: ✅] (same as HTTP ingress)
  securityHeaders:
    enabled: false
    hsts: true
    hstsMaxAge: 31536000
    hstsIncludeSubdomains: true
    hstsPreload: false
    frameOptions: "SAMEORIGIN"
    contentTypeNosniff: true
    xssProtection: "1; mode=block"
    referrerPolicy: "strict-origin-when-cross-origin"
    csp: ""

  # SSL/TLS Configuration
  ssl:
    redirect: true                          # [HAProxy: ✅ | NGINX: ✅]
    protocols: "TLSv1.2 TLSv1.3"           # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    ciphers: ""                             # [HAProxy: ❌ ConfigMap | NGINX: ✅]

  # Performance & Reliability
  proxy:
    bodySize: "8m"                          # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    connectTimeout: 60                      # [HAProxy: ✅ | NGINX: ✅]
    sendTimeout: 60                         # [HAProxy: ✅ timeout-server | NGINX: ✅]
    readTimeout: 60                         # [HAProxy: ✅ timeout-server | NGINX: ✅]
    bufferSize: "4k"                        # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    buffersNumber: 4                        # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    nextUpstream: "error timeout"           # [HAProxy: ❌ ConfigMap | NGINX: ✅]
    nextUpstreamTries: 3                    # [HAProxy: ❌ ConfigMap | NGINX: ✅]

  # Rate Limiting [HAProxy: ✅ | NGINX: ✅]
  rateLimit:
    enabled: false
    rps: 100                                # [HAProxy: ✅ | NGINX: ✅]
    burst: 200                              # [HAProxy: ❌ | NGINX: ✅]
    key: "$binary_remote_addr"              # [HAProxy: ❌ | NGINX: ❌]

  # Canary Deployment [HAProxy: ❌ | NGINX: ✅]
  canary:
    enabled: false
    weight: 0

  # Custom annotations
  extraAnnotations: {}

  # Extra labels
  extraLabels: {}

  hosts:
    - host: fqdn.shiftlabs.dev
      paths:
        - path: /
          pathType: Prefix

  tls:
    - secretName: shiftlabsdev-ssl-cert
      hosts:
        - fqdn.shiftlabs.dev

# Health Check Probes - Modern Best Practice Configuration
probes:
  # Startup Probe - For slow-starting applications
  # Protects liveness probe from killing container during startup
  startup:
    enabled: true
    type: http  # http, tcp, grpc, exec

    # HTTP probe configuration
    http:
      path: /api/v1/health/healthz
      port: http  # Can be port name or number
      scheme: HTTP
      httpHeaders: []
        # - name: Authorization
        #   value: Bearer token

    # TCP probe configuration
    tcp:
      port: 8080

    # GRPC probe configuration (Kubernetes 1.24+)
    grpc:
      port: 9090
      service: ""  # Optional gRPC service name

    # Exec probe configuration
    exec:
      command: []
        # - cat
        # - /tmp/healthy

    # Timing configuration - Tolerant for slow startup
    initialDelaySeconds: 0  # Kubernetes 1.20+ best practice
    periodSeconds: 10  # Check every 10 seconds
    timeoutSeconds: 1  # Request timeout
    failureThreshold: 30  # 30 * 10 = 300s (5 minutes) max startup time
    successThreshold: 1  # Success once = ready

  # Liveness Probe - Is the application running?
  # Should be conservative to avoid cascade failures
  liveness:
    enabled: true
    type: http

    http:
      path: /api/v1/health/readyz
      port: http
      scheme: HTTP
      httpHeaders: []

    tcp:
      port: 8080

    grpc:
      port: 9090
      service: ""

    exec:
      command: []

    # Timing configuration - Conservative
    initialDelaySeconds: 0  # Startup probe handles initial delay
    periodSeconds: 10  # Check every 10 seconds
    timeoutSeconds: 1
    failureThreshold: 3  # 3 failures = restart (30 seconds)
    successThreshold: 1

  # Readiness Probe - Is the application ready to serve traffic?
  # Should be responsive for quick traffic routing
  readiness:
    enabled: true
    type: http

    http:
      path: /api/v1/health/readyz
      port: http
      scheme: HTTP
      httpHeaders: []

    tcp:
      port: 8080

    grpc:
      port: 9090
      service: ""

    exec:
      command: []

    # Timing configuration - Responsive
    initialDelaySeconds: 0
    periodSeconds: 5  # Check every 5 seconds (faster recovery)
    timeoutSeconds: 1
    failureThreshold: 3  # 3 failures = remove from service (15 seconds)
    successThreshold: 1  # 1 success = add to service (5 seconds)

resources:
  limits:
    cpu: 250m
    memory: 250Mi
  requests:
    cpu: 250m
    memory: 250Mi

# Deployment strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: "25%"
    maxUnavailable: "25%"
minReadySeconds: 0

autoscaling:
  enabled: true
  type: keda
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 85
  targetMemoryUtilizationPercentage: 85

podDisruptionBudget:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 1

networkPolicy:
  enabled: false
  defaultDeny: false
  allowDNS: true
  policyTypes:
    - Ingress
    - Egress
  ingress: []
    # - from:
    #   - namespaceSelector:
    #       matchLabels:
    #         name: default
    #   ports:
    #   - protocol: TCP
    #     port: 80
  egress: []
    # - to:
    #   - namespaceSelector: {}
    #   ports:
    #   - protocol: TCP
    #     port: 443

configmap:
  enabled: false
  keyValues:
    SPECIAL_KEY1: SPECIAL_KEY1
    SPECIAL_KEY2: SPECIAL_KEY2
  fileData:
    - fileName: custom-config1.yaml
      mountPath: /tmp
      content: |-
        key1: value1
        key2: value2
    - fileName: custom-config2.yaml
      mountPath: /tmp
      content: |-
        key3: value3
        key4: value4

# Scheduling
topologySpreadConstraints: []
terminationGracePeriodSeconds: 30
dnsPolicy: ""
dnsConfig: {}
hostAliases: []
priorityClassName: ""
runtimeClassName: ""
shareProcessNamespace: false

# Extra extensibility
extraVolumes: []
extraVolumeMounts: []
extraContainers: []
extraEnvFrom: []
extraInitContainers: []

# Lifecycle hooks
lifecycle: {}
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "sleep 10"]
  # postStart:
  #   exec:
  #     command: ["/bin/sh", "-c", "echo started"]

# Labels & Annotations
podLabels: {}
commonLabels: {}
commonAnnotations: {}
component: ""
partOf: ""

# Monitoring
metrics:
  serviceMonitor:
    enabled: false
    additionalLabels: {}
    namespace: ""
    endpoints:
      - port: http
        path: /metrics
        interval: 30s
        scrapeTimeout: 10s
  podMonitor:
    enabled: false
    additionalLabels: {}
    namespace: ""
    podMetricsEndpoints:
      - port: http
        path: /metrics
        interval: 30s

# Vertical Pod Autoscaler
verticalPodAutoscaler:
  enabled: false
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies: []

nodeSelector: {}

tolerations: []

affinity: {}
